// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RobotRemoteControl.proto

#ifndef PROTOBUF_RobotRemoteControl_2eproto__INCLUDED
#define PROTOBUF_RobotRemoteControl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace robot_remote_control {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_RobotRemoteControl_2eproto();
void protobuf_AssignDesc_RobotRemoteControl_2eproto();
void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

class ComplexAction;
class ComplexActions;
class GoTo;
class JointState;
class LogMessage;
class Orientation;
class Pose;
class Poses;
class Position;
class RobotName;
class RobotState;
class SimpleAction;
class SimpleActionDef;
class SimpleActions;
class SimpleSensor;
class SimpleSensors;
class Transform;
class Twist;
class Vector2;
class Vector3;
class VideoStream;
class VideoStreams;

enum SimpleActionType {
  VALUE = 0,
  TRIGGER = 1,
  SimpleActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SimpleActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SimpleActionType_IsValid(int value);
const SimpleActionType SimpleActionType_MIN = VALUE;
const SimpleActionType SimpleActionType_MAX = TRIGGER;
const int SimpleActionType_ARRAYSIZE = SimpleActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SimpleActionType_descriptor();
inline const ::std::string& SimpleActionType_Name(SimpleActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SimpleActionType_descriptor(), value);
}
inline bool SimpleActionType_Parse(
    const ::std::string& name, SimpleActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SimpleActionType>(
    SimpleActionType_descriptor(), name, value);
}
enum ComplexActionType {
  POSE = 0,
  POSE_LIST = 1,
  AREA = 2,
  VOLUME = 3,
  ComplexActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ComplexActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ComplexActionType_IsValid(int value);
const ComplexActionType ComplexActionType_MIN = POSE;
const ComplexActionType ComplexActionType_MAX = VOLUME;
const int ComplexActionType_ARRAYSIZE = ComplexActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComplexActionType_descriptor();
inline const ::std::string& ComplexActionType_Name(ComplexActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComplexActionType_descriptor(), value);
}
inline bool ComplexActionType_Parse(
    const ::std::string& name, ComplexActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComplexActionType>(
    ComplexActionType_descriptor(), name, value);
}
// ===================================================================

class Vector2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.Vector2) */ {
 public:
  Vector2();
  virtual ~Vector2();

  Vector2(const Vector2& from);

  inline Vector2& operator=(const Vector2& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector2& default_instance();

  void Swap(Vector2* other);

  // implements Message ----------------------------------------------

  inline Vector2* New() const { return New(NULL); }

  Vector2* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector2& from);
  void MergeFrom(const Vector2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:robot_remote_control.Vector2)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float x_;
  float y_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static Vector2* default_instance_;
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  inline Vector3* New() const { return New(NULL); }

  Vector3* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:robot_remote_control.Vector3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:robot_remote_control.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double x_;
  double y_;
  double z_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Orientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.Orientation) */ {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Orientation& default_instance();

  void Swap(Orientation* other);

  // implements Message ----------------------------------------------

  inline Orientation* New() const { return New(NULL); }

  Orientation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Orientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double w = 4;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:robot_remote_control.Orientation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double x_;
  double y_;
  double z_;
  double w_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static Orientation* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  inline Pose* New() const { return New(NULL); }

  Pose* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robot_remote_control.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::robot_remote_control::Position& position() const;
  ::robot_remote_control::Position* mutable_position();
  ::robot_remote_control::Position* release_position();
  void set_allocated_position(::robot_remote_control::Position* position);

  // optional .robot_remote_control.Orientation orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::robot_remote_control::Orientation& orientation() const;
  ::robot_remote_control::Orientation* mutable_orientation();
  ::robot_remote_control::Orientation* release_orientation();
  void set_allocated_orientation(::robot_remote_control::Orientation* orientation);

  // @@protoc_insertion_point(class_scope:robot_remote_control.Pose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::robot_remote_control::Position* position_;
  ::robot_remote_control::Orientation* orientation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class Poses : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.Poses) */ {
 public:
  Poses();
  virtual ~Poses();

  Poses(const Poses& from);

  inline Poses& operator=(const Poses& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Poses& default_instance();

  void Swap(Poses* other);

  // implements Message ----------------------------------------------

  inline Poses* New() const { return New(NULL); }

  Poses* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Poses& from);
  void MergeFrom(const Poses& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Poses* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robot_remote_control.Pose pose = 1;
  int pose_size() const;
  void clear_pose();
  static const int kPoseFieldNumber = 1;
  const ::robot_remote_control::Pose& pose(int index) const;
  ::robot_remote_control::Pose* mutable_pose(int index);
  ::robot_remote_control::Pose* add_pose();
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose >*
      mutable_pose();
  const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose >&
      pose() const;

  // @@protoc_insertion_point(class_scope:robot_remote_control.Poses)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose > pose_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static Poses* default_instance_;
};
// -------------------------------------------------------------------

class Transform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.Transform) */ {
 public:
  Transform();
  virtual ~Transform();

  Transform(const Transform& from);

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transform& default_instance();

  void Swap(Transform* other);

  // implements Message ----------------------------------------------

  inline Transform* New() const { return New(NULL); }

  Transform* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transform* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robot_remote_control.Pose transform = 1;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 1;
  const ::robot_remote_control::Pose& transform() const;
  ::robot_remote_control::Pose* mutable_transform();
  ::robot_remote_control::Pose* release_transform();
  void set_allocated_transform(::robot_remote_control::Pose* transform);

  // optional string from = 2;
  void clear_from();
  static const int kFromFieldNumber = 2;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // optional string to = 3;
  void clear_to();
  static const int kToFieldNumber = 3;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // @@protoc_insertion_point(class_scope:robot_remote_control.Transform)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::robot_remote_control::Pose* transform_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static Transform* default_instance_;
};
// -------------------------------------------------------------------

class Twist : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.Twist) */ {
 public:
  Twist();
  virtual ~Twist();

  Twist(const Twist& from);

  inline Twist& operator=(const Twist& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Twist& default_instance();

  void Swap(Twist* other);

  // implements Message ----------------------------------------------

  inline Twist* New() const { return New(NULL); }

  Twist* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Twist& from);
  void MergeFrom(const Twist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Twist* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robot_remote_control.Vector3 linear = 1;
  bool has_linear() const;
  void clear_linear();
  static const int kLinearFieldNumber = 1;
  const ::robot_remote_control::Vector3& linear() const;
  ::robot_remote_control::Vector3* mutable_linear();
  ::robot_remote_control::Vector3* release_linear();
  void set_allocated_linear(::robot_remote_control::Vector3* linear);

  // optional .robot_remote_control.Vector3 angular = 2;
  bool has_angular() const;
  void clear_angular();
  static const int kAngularFieldNumber = 2;
  const ::robot_remote_control::Vector3& angular() const;
  ::robot_remote_control::Vector3* mutable_angular();
  ::robot_remote_control::Vector3* release_angular();
  void set_allocated_angular(::robot_remote_control::Vector3* angular);

  // @@protoc_insertion_point(class_scope:robot_remote_control.Twist)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::robot_remote_control::Vector3* linear_;
  ::robot_remote_control::Vector3* angular_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static Twist* default_instance_;
};
// -------------------------------------------------------------------

class JointState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.JointState) */ {
 public:
  JointState();
  virtual ~JointState();

  JointState(const JointState& from);

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointState& default_instance();

  void Swap(JointState* other);

  // implements Message ----------------------------------------------

  inline JointState* New() const { return New(NULL); }

  JointState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JointState& from);
  void MergeFrom(const JointState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JointState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string name = 1;
  int name_size() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name(int index) const;
  ::std::string* mutable_name(int index);
  void set_name(int index, const ::std::string& value);
  void set_name(int index, const char* value);
  void set_name(int index, const char* value, size_t size);
  ::std::string* add_name();
  void add_name(const ::std::string& value);
  void add_name(const char* value);
  void add_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // repeated double position = 2;
  int position_size() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  double position(int index) const;
  void set_position(int index, double value);
  void add_position(double value);
  const ::google::protobuf::RepeatedField< double >&
      position() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_position();

  // repeated double velocity = 3;
  int velocity_size() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  double velocity(int index) const;
  void set_velocity(int index, double value);
  void add_velocity(double value);
  const ::google::protobuf::RepeatedField< double >&
      velocity() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_velocity();

  // repeated double effort = 4;
  int effort_size() const;
  void clear_effort();
  static const int kEffortFieldNumber = 4;
  double effort(int index) const;
  void set_effort(int index, double value);
  void add_effort(double value);
  const ::google::protobuf::RepeatedField< double >&
      effort() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_effort();

  // @@protoc_insertion_point(class_scope:robot_remote_control.JointState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  ::google::protobuf::RepeatedField< double > position_;
  mutable int _position_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > velocity_;
  mutable int _velocity_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > effort_;
  mutable int _effort_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static JointState* default_instance_;
};
// -------------------------------------------------------------------

class GoTo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.GoTo) */ {
 public:
  GoTo();
  virtual ~GoTo();

  GoTo(const GoTo& from);

  inline GoTo& operator=(const GoTo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoTo& default_instance();

  void Swap(GoTo* other);

  // implements Message ----------------------------------------------

  inline GoTo* New() const { return New(NULL); }

  GoTo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GoTo& from);
  void MergeFrom(const GoTo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GoTo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_forward_speed = 1;
  void clear_max_forward_speed();
  static const int kMaxForwardSpeedFieldNumber = 1;
  double max_forward_speed() const;
  void set_max_forward_speed(double value);

  // optional .robot_remote_control.Vector3 waypoint_point = 2;
  bool has_waypoint_point() const;
  void clear_waypoint_point();
  static const int kWaypointPointFieldNumber = 2;
  const ::robot_remote_control::Vector3& waypoint_point() const;
  ::robot_remote_control::Vector3* mutable_waypoint_point();
  ::robot_remote_control::Vector3* release_waypoint_point();
  void set_allocated_waypoint_point(::robot_remote_control::Vector3* waypoint_point);

  // optional double waypoint_max_forward_speed = 3;
  void clear_waypoint_max_forward_speed();
  static const int kWaypointMaxForwardSpeedFieldNumber = 3;
  double waypoint_max_forward_speed() const;
  void set_waypoint_max_forward_speed(double value);

  // @@protoc_insertion_point(class_scope:robot_remote_control.GoTo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double max_forward_speed_;
  ::robot_remote_control::Vector3* waypoint_point_;
  double waypoint_max_forward_speed_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static GoTo* default_instance_;
};
// -------------------------------------------------------------------

class SimpleActionDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.SimpleActionDef) */ {
 public:
  SimpleActionDef();
  virtual ~SimpleActionDef();

  SimpleActionDef(const SimpleActionDef& from);

  inline SimpleActionDef& operator=(const SimpleActionDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleActionDef& default_instance();

  void Swap(SimpleActionDef* other);

  // implements Message ----------------------------------------------

  inline SimpleActionDef* New() const { return New(NULL); }

  SimpleActionDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleActionDef& from);
  void MergeFrom(const SimpleActionDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleActionDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .robot_remote_control.SimpleActionType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::robot_remote_control::SimpleActionType type() const;
  void set_type(::robot_remote_control::SimpleActionType value);

  // optional uint64 max_state = 2;
  void clear_max_state();
  static const int kMaxStateFieldNumber = 2;
  ::google::protobuf::uint64 max_state() const;
  void set_max_state(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:robot_remote_control.SimpleActionDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 max_state_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static SimpleActionDef* default_instance_;
};
// -------------------------------------------------------------------

class SimpleAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.SimpleAction) */ {
 public:
  SimpleAction();
  virtual ~SimpleAction();

  SimpleAction(const SimpleAction& from);

  inline SimpleAction& operator=(const SimpleAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleAction& default_instance();

  void Swap(SimpleAction* other);

  // implements Message ----------------------------------------------

  inline SimpleAction* New() const { return New(NULL); }

  SimpleAction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleAction& from);
  void MergeFrom(const SimpleAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .robot_remote_control.SimpleActionDef type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::robot_remote_control::SimpleActionDef& type() const;
  ::robot_remote_control::SimpleActionDef* mutable_type();
  ::robot_remote_control::SimpleActionDef* release_type();
  void set_allocated_type(::robot_remote_control::SimpleActionDef* type);

  // optional uint64 state = 3;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::google::protobuf::uint64 state() const;
  void set_state(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:robot_remote_control.SimpleAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::robot_remote_control::SimpleActionDef* type_;
  ::google::protobuf::uint64 state_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static SimpleAction* default_instance_;
};
// -------------------------------------------------------------------

class SimpleActions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.SimpleActions) */ {
 public:
  SimpleActions();
  virtual ~SimpleActions();

  SimpleActions(const SimpleActions& from);

  inline SimpleActions& operator=(const SimpleActions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleActions& default_instance();

  void Swap(SimpleActions* other);

  // implements Message ----------------------------------------------

  inline SimpleActions* New() const { return New(NULL); }

  SimpleActions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleActions& from);
  void MergeFrom(const SimpleActions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleActions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robot_remote_control.SimpleAction actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  const ::robot_remote_control::SimpleAction& actions(int index) const;
  ::robot_remote_control::SimpleAction* mutable_actions(int index);
  ::robot_remote_control::SimpleAction* add_actions();
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleAction >*
      mutable_actions();
  const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleAction >&
      actions() const;

  // @@protoc_insertion_point(class_scope:robot_remote_control.SimpleActions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleAction > actions_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static SimpleActions* default_instance_;
};
// -------------------------------------------------------------------

class ComplexAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.ComplexAction) */ {
 public:
  ComplexAction();
  virtual ~ComplexAction();

  ComplexAction(const ComplexAction& from);

  inline ComplexAction& operator=(const ComplexAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexAction& default_instance();

  void Swap(ComplexAction* other);

  // implements Message ----------------------------------------------

  inline ComplexAction* New() const { return New(NULL); }

  ComplexAction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComplexAction& from);
  void MergeFrom(const ComplexAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComplexAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .robot_remote_control.ComplexActionType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::robot_remote_control::ComplexActionType type() const;
  void set_type(::robot_remote_control::ComplexActionType value);

  // repeated .robot_remote_control.Pose poses = 3;
  int poses_size() const;
  void clear_poses();
  static const int kPosesFieldNumber = 3;
  const ::robot_remote_control::Pose& poses(int index) const;
  ::robot_remote_control::Pose* mutable_poses(int index);
  ::robot_remote_control::Pose* add_poses();
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose >*
      mutable_poses();
  const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose >&
      poses() const;

  // @@protoc_insertion_point(class_scope:robot_remote_control.ComplexAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose > poses_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static ComplexAction* default_instance_;
};
// -------------------------------------------------------------------

class ComplexActions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.ComplexActions) */ {
 public:
  ComplexActions();
  virtual ~ComplexActions();

  ComplexActions(const ComplexActions& from);

  inline ComplexActions& operator=(const ComplexActions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexActions& default_instance();

  void Swap(ComplexActions* other);

  // implements Message ----------------------------------------------

  inline ComplexActions* New() const { return New(NULL); }

  ComplexActions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComplexActions& from);
  void MergeFrom(const ComplexActions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComplexActions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robot_remote_control.ComplexAction actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  const ::robot_remote_control::ComplexAction& actions(int index) const;
  ::robot_remote_control::ComplexAction* mutable_actions(int index);
  ::robot_remote_control::ComplexAction* add_actions();
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::ComplexAction >*
      mutable_actions();
  const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::ComplexAction >&
      actions() const;

  // @@protoc_insertion_point(class_scope:robot_remote_control.ComplexActions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::ComplexAction > actions_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static ComplexActions* default_instance_;
};
// -------------------------------------------------------------------

class RobotName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.RobotName) */ {
 public:
  RobotName();
  virtual ~RobotName();

  RobotName(const RobotName& from);

  inline RobotName& operator=(const RobotName& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotName& default_instance();

  void Swap(RobotName* other);

  // implements Message ----------------------------------------------

  inline RobotName* New() const { return New(NULL); }

  RobotName* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotName& from);
  void MergeFrom(const RobotName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:robot_remote_control.RobotName)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static RobotName* default_instance_;
};
// -------------------------------------------------------------------

class RobotState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.RobotState) */ {
 public:
  RobotState();
  virtual ~RobotState();

  RobotState(const RobotState& from);

  inline RobotState& operator=(const RobotState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotState& default_instance();

  void Swap(RobotState* other);

  // implements Message ----------------------------------------------

  inline RobotState* New() const { return New(NULL); }

  RobotState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotState& from);
  void MergeFrom(const RobotState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string state = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // @@protoc_insertion_point(class_scope:robot_remote_control.RobotState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static RobotState* default_instance_;
};
// -------------------------------------------------------------------

class LogMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.LogMessage) */ {
 public:
  LogMessage();
  virtual ~LogMessage();

  LogMessage(const LogMessage& from);

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMessage& default_instance();

  void Swap(LogMessage* other);

  // implements Message ----------------------------------------------

  inline LogMessage* New() const { return New(NULL); }

  LogMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // optional string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:robot_remote_control.LogMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 level_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static LogMessage* default_instance_;
};
// -------------------------------------------------------------------

class VideoStream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.VideoStream) */ {
 public:
  VideoStream();
  virtual ~VideoStream();

  VideoStream(const VideoStream& from);

  inline VideoStream& operator=(const VideoStream& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoStream& default_instance();

  void Swap(VideoStream* other);

  // implements Message ----------------------------------------------

  inline VideoStream* New() const { return New(NULL); }

  VideoStream* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoStream& from);
  void MergeFrom(const VideoStream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoStream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional .robot_remote_control.Pose camerapose = 2;
  bool has_camerapose() const;
  void clear_camerapose();
  static const int kCameraposeFieldNumber = 2;
  const ::robot_remote_control::Pose& camerapose() const;
  ::robot_remote_control::Pose* mutable_camerapose();
  ::robot_remote_control::Pose* release_camerapose();
  void set_allocated_camerapose(::robot_remote_control::Pose* camerapose);

  // @@protoc_insertion_point(class_scope:robot_remote_control.VideoStream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::robot_remote_control::Pose* camerapose_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static VideoStream* default_instance_;
};
// -------------------------------------------------------------------

class VideoStreams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.VideoStreams) */ {
 public:
  VideoStreams();
  virtual ~VideoStreams();

  VideoStreams(const VideoStreams& from);

  inline VideoStreams& operator=(const VideoStreams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoStreams& default_instance();

  void Swap(VideoStreams* other);

  // implements Message ----------------------------------------------

  inline VideoStreams* New() const { return New(NULL); }

  VideoStreams* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoStreams& from);
  void MergeFrom(const VideoStreams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoStreams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robot_remote_control.VideoStream stream = 1;
  int stream_size() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  const ::robot_remote_control::VideoStream& stream(int index) const;
  ::robot_remote_control::VideoStream* mutable_stream(int index);
  ::robot_remote_control::VideoStream* add_stream();
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::VideoStream >*
      mutable_stream();
  const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::VideoStream >&
      stream() const;

  // @@protoc_insertion_point(class_scope:robot_remote_control.VideoStreams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::VideoStream > stream_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static VideoStreams* default_instance_;
};
// -------------------------------------------------------------------

class SimpleSensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.SimpleSensor) */ {
 public:
  SimpleSensor();
  virtual ~SimpleSensor();

  SimpleSensor(const SimpleSensor& from);

  inline SimpleSensor& operator=(const SimpleSensor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleSensor& default_instance();

  void Swap(SimpleSensor* other);

  // implements Message ----------------------------------------------

  inline SimpleSensor* New() const { return New(NULL); }

  SimpleSensor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleSensor& from);
  void MergeFrom(const SimpleSensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleSensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional .robot_remote_control.Vector2 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  const ::robot_remote_control::Vector2& size() const;
  ::robot_remote_control::Vector2* mutable_size();
  ::robot_remote_control::Vector2* release_size();
  void set_allocated_size(::robot_remote_control::Vector2* size);

  // repeated float value = 4;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  float value(int index) const;
  void set_value(int index, float value);
  void add_value(float value);
  const ::google::protobuf::RepeatedField< float >&
      value() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:robot_remote_control.SimpleSensor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::robot_remote_control::Vector2* size_;
  ::google::protobuf::RepeatedField< float > value_;
  mutable int _value_cached_byte_size_;
  ::google::protobuf::uint32 id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static SimpleSensor* default_instance_;
};
// -------------------------------------------------------------------

class SimpleSensors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_remote_control.SimpleSensors) */ {
 public:
  SimpleSensors();
  virtual ~SimpleSensors();

  SimpleSensors(const SimpleSensors& from);

  inline SimpleSensors& operator=(const SimpleSensors& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleSensors& default_instance();

  void Swap(SimpleSensors* other);

  // implements Message ----------------------------------------------

  inline SimpleSensors* New() const { return New(NULL); }

  SimpleSensors* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleSensors& from);
  void MergeFrom(const SimpleSensors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleSensors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robot_remote_control.SimpleSensor sensors = 1;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 1;
  const ::robot_remote_control::SimpleSensor& sensors(int index) const;
  ::robot_remote_control::SimpleSensor* mutable_sensors(int index);
  ::robot_remote_control::SimpleSensor* add_sensors();
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleSensor >*
      mutable_sensors();
  const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleSensor >&
      sensors() const;

  // @@protoc_insertion_point(class_scope:robot_remote_control.SimpleSensors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleSensor > sensors_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_RobotRemoteControl_2eproto();
  friend void protobuf_AssignDesc_RobotRemoteControl_2eproto();
  friend void protobuf_ShutdownFile_RobotRemoteControl_2eproto();

  void InitAsDefaultInstance();
  static SimpleSensors* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector2

// optional float x = 1;
inline void Vector2::clear_x() {
  x_ = 0;
}
inline float Vector2::x() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Vector2.x)
  return x_;
}
inline void Vector2::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Vector2.x)
}

// optional float y = 2;
inline void Vector2::clear_y() {
  y_ = 0;
}
inline float Vector2::y() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Vector2.y)
  return y_;
}
inline void Vector2::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Vector2.y)
}

// -------------------------------------------------------------------

// Vector3

// optional float x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Vector3.x)
}

// optional float y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Vector3.y)
}

// optional float z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Vector3.z)
}

// -------------------------------------------------------------------

// Position

// optional double x = 1;
inline void Position::clear_x() {
  x_ = 0;
}
inline double Position::x() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Position.x)
  return x_;
}
inline void Position::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Position.x)
}

// optional double y = 2;
inline void Position::clear_y() {
  y_ = 0;
}
inline double Position::y() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Position.y)
  return y_;
}
inline void Position::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Position.y)
}

// optional double z = 3;
inline void Position::clear_z() {
  z_ = 0;
}
inline double Position::z() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Position.z)
  return z_;
}
inline void Position::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Position.z)
}

// -------------------------------------------------------------------

// Orientation

// optional double x = 1;
inline void Orientation::clear_x() {
  x_ = 0;
}
inline double Orientation::x() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Orientation.x)
  return x_;
}
inline void Orientation::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Orientation.x)
}

// optional double y = 2;
inline void Orientation::clear_y() {
  y_ = 0;
}
inline double Orientation::y() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Orientation.y)
  return y_;
}
inline void Orientation::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Orientation.y)
}

// optional double z = 3;
inline void Orientation::clear_z() {
  z_ = 0;
}
inline double Orientation::z() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Orientation.z)
  return z_;
}
inline void Orientation::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Orientation.z)
}

// optional double w = 4;
inline void Orientation::clear_w() {
  w_ = 0;
}
inline double Orientation::w() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Orientation.w)
  return w_;
}
inline void Orientation::set_w(double value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.Orientation.w)
}

// -------------------------------------------------------------------

// Pose

// optional .robot_remote_control.Position position = 1;
inline bool Pose::has_position() const {
  return !_is_default_instance_ && position_ != NULL;
}
inline void Pose::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) delete position_;
  position_ = NULL;
}
inline const ::robot_remote_control::Position& Pose::position() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Pose.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::robot_remote_control::Position* Pose::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::robot_remote_control::Position;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.Pose.position)
  return position_;
}
inline ::robot_remote_control::Position* Pose::release_position() {
  // @@protoc_insertion_point(field_release:robot_remote_control.Pose.position)
  
  ::robot_remote_control::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Pose::set_allocated_position(::robot_remote_control::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.Pose.position)
}

// optional .robot_remote_control.Orientation orientation = 2;
inline bool Pose::has_orientation() const {
  return !_is_default_instance_ && orientation_ != NULL;
}
inline void Pose::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) delete orientation_;
  orientation_ = NULL;
}
inline const ::robot_remote_control::Orientation& Pose::orientation() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Pose.orientation)
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::robot_remote_control::Orientation* Pose::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::robot_remote_control::Orientation;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.Pose.orientation)
  return orientation_;
}
inline ::robot_remote_control::Orientation* Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:robot_remote_control.Pose.orientation)
  
  ::robot_remote_control::Orientation* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_orientation(::robot_remote_control::Orientation* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.Pose.orientation)
}

// -------------------------------------------------------------------

// Poses

// repeated .robot_remote_control.Pose pose = 1;
inline int Poses::pose_size() const {
  return pose_.size();
}
inline void Poses::clear_pose() {
  pose_.Clear();
}
inline const ::robot_remote_control::Pose& Poses::pose(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Poses.pose)
  return pose_.Get(index);
}
inline ::robot_remote_control::Pose* Poses::mutable_pose(int index) {
  // @@protoc_insertion_point(field_mutable:robot_remote_control.Poses.pose)
  return pose_.Mutable(index);
}
inline ::robot_remote_control::Pose* Poses::add_pose() {
  // @@protoc_insertion_point(field_add:robot_remote_control.Poses.pose)
  return pose_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose >*
Poses::mutable_pose() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.Poses.pose)
  return &pose_;
}
inline const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose >&
Poses::pose() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.Poses.pose)
  return pose_;
}

// -------------------------------------------------------------------

// Transform

// optional .robot_remote_control.Pose transform = 1;
inline bool Transform::has_transform() const {
  return !_is_default_instance_ && transform_ != NULL;
}
inline void Transform::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) delete transform_;
  transform_ = NULL;
}
inline const ::robot_remote_control::Pose& Transform::transform() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Transform.transform)
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
}
inline ::robot_remote_control::Pose* Transform::mutable_transform() {
  
  if (transform_ == NULL) {
    transform_ = new ::robot_remote_control::Pose;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.Transform.transform)
  return transform_;
}
inline ::robot_remote_control::Pose* Transform::release_transform() {
  // @@protoc_insertion_point(field_release:robot_remote_control.Transform.transform)
  
  ::robot_remote_control::Pose* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void Transform::set_allocated_transform(::robot_remote_control::Pose* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.Transform.transform)
}

// optional string from = 2;
inline void Transform::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transform::from() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Transform.from)
  return from_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transform::set_from(const ::std::string& value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.Transform.from)
}
inline void Transform::set_from(const char* value) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.Transform.from)
}
inline void Transform::set_from(const char* value, size_t size) {
  
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.Transform.from)
}
inline ::std::string* Transform::mutable_from() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.Transform.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transform::release_from() {
  // @@protoc_insertion_point(field_release:robot_remote_control.Transform.from)
  
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transform::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    
  } else {
    
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.Transform.from)
}

// optional string to = 3;
inline void Transform::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transform::to() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Transform.to)
  return to_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transform::set_to(const ::std::string& value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.Transform.to)
}
inline void Transform::set_to(const char* value) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.Transform.to)
}
inline void Transform::set_to(const char* value, size_t size) {
  
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.Transform.to)
}
inline ::std::string* Transform::mutable_to() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.Transform.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transform::release_to() {
  // @@protoc_insertion_point(field_release:robot_remote_control.Transform.to)
  
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transform::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    
  } else {
    
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.Transform.to)
}

// -------------------------------------------------------------------

// Twist

// optional .robot_remote_control.Vector3 linear = 1;
inline bool Twist::has_linear() const {
  return !_is_default_instance_ && linear_ != NULL;
}
inline void Twist::clear_linear() {
  if (GetArenaNoVirtual() == NULL && linear_ != NULL) delete linear_;
  linear_ = NULL;
}
inline const ::robot_remote_control::Vector3& Twist::linear() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Twist.linear)
  return linear_ != NULL ? *linear_ : *default_instance_->linear_;
}
inline ::robot_remote_control::Vector3* Twist::mutable_linear() {
  
  if (linear_ == NULL) {
    linear_ = new ::robot_remote_control::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.Twist.linear)
  return linear_;
}
inline ::robot_remote_control::Vector3* Twist::release_linear() {
  // @@protoc_insertion_point(field_release:robot_remote_control.Twist.linear)
  
  ::robot_remote_control::Vector3* temp = linear_;
  linear_ = NULL;
  return temp;
}
inline void Twist::set_allocated_linear(::robot_remote_control::Vector3* linear) {
  delete linear_;
  linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.Twist.linear)
}

// optional .robot_remote_control.Vector3 angular = 2;
inline bool Twist::has_angular() const {
  return !_is_default_instance_ && angular_ != NULL;
}
inline void Twist::clear_angular() {
  if (GetArenaNoVirtual() == NULL && angular_ != NULL) delete angular_;
  angular_ = NULL;
}
inline const ::robot_remote_control::Vector3& Twist::angular() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.Twist.angular)
  return angular_ != NULL ? *angular_ : *default_instance_->angular_;
}
inline ::robot_remote_control::Vector3* Twist::mutable_angular() {
  
  if (angular_ == NULL) {
    angular_ = new ::robot_remote_control::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.Twist.angular)
  return angular_;
}
inline ::robot_remote_control::Vector3* Twist::release_angular() {
  // @@protoc_insertion_point(field_release:robot_remote_control.Twist.angular)
  
  ::robot_remote_control::Vector3* temp = angular_;
  angular_ = NULL;
  return temp;
}
inline void Twist::set_allocated_angular(::robot_remote_control::Vector3* angular) {
  delete angular_;
  angular_ = angular;
  if (angular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.Twist.angular)
}

// -------------------------------------------------------------------

// JointState

// repeated string name = 1;
inline int JointState::name_size() const {
  return name_.size();
}
inline void JointState::clear_name() {
  name_.Clear();
}
inline const ::std::string& JointState::name(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.JointState.name)
  return name_.Get(index);
}
inline ::std::string* JointState::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:robot_remote_control.JointState.name)
  return name_.Mutable(index);
}
inline void JointState::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:robot_remote_control.JointState.name)
  name_.Mutable(index)->assign(value);
}
inline void JointState::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:robot_remote_control.JointState.name)
}
inline void JointState::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.JointState.name)
}
inline ::std::string* JointState::add_name() {
  // @@protoc_insertion_point(field_add_mutable:robot_remote_control.JointState.name)
  return name_.Add();
}
inline void JointState::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:robot_remote_control.JointState.name)
}
inline void JointState::add_name(const char* value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:robot_remote_control.JointState.name)
}
inline void JointState::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:robot_remote_control.JointState.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
JointState::name() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.JointState.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
JointState::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.JointState.name)
  return &name_;
}

// repeated double position = 2;
inline int JointState::position_size() const {
  return position_.size();
}
inline void JointState::clear_position() {
  position_.Clear();
}
inline double JointState::position(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.JointState.position)
  return position_.Get(index);
}
inline void JointState::set_position(int index, double value) {
  position_.Set(index, value);
  // @@protoc_insertion_point(field_set:robot_remote_control.JointState.position)
}
inline void JointState::add_position(double value) {
  position_.Add(value);
  // @@protoc_insertion_point(field_add:robot_remote_control.JointState.position)
}
inline const ::google::protobuf::RepeatedField< double >&
JointState::position() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.JointState.position)
  return position_;
}
inline ::google::protobuf::RepeatedField< double >*
JointState::mutable_position() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.JointState.position)
  return &position_;
}

// repeated double velocity = 3;
inline int JointState::velocity_size() const {
  return velocity_.size();
}
inline void JointState::clear_velocity() {
  velocity_.Clear();
}
inline double JointState::velocity(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.JointState.velocity)
  return velocity_.Get(index);
}
inline void JointState::set_velocity(int index, double value) {
  velocity_.Set(index, value);
  // @@protoc_insertion_point(field_set:robot_remote_control.JointState.velocity)
}
inline void JointState::add_velocity(double value) {
  velocity_.Add(value);
  // @@protoc_insertion_point(field_add:robot_remote_control.JointState.velocity)
}
inline const ::google::protobuf::RepeatedField< double >&
JointState::velocity() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.JointState.velocity)
  return velocity_;
}
inline ::google::protobuf::RepeatedField< double >*
JointState::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.JointState.velocity)
  return &velocity_;
}

// repeated double effort = 4;
inline int JointState::effort_size() const {
  return effort_.size();
}
inline void JointState::clear_effort() {
  effort_.Clear();
}
inline double JointState::effort(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.JointState.effort)
  return effort_.Get(index);
}
inline void JointState::set_effort(int index, double value) {
  effort_.Set(index, value);
  // @@protoc_insertion_point(field_set:robot_remote_control.JointState.effort)
}
inline void JointState::add_effort(double value) {
  effort_.Add(value);
  // @@protoc_insertion_point(field_add:robot_remote_control.JointState.effort)
}
inline const ::google::protobuf::RepeatedField< double >&
JointState::effort() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.JointState.effort)
  return effort_;
}
inline ::google::protobuf::RepeatedField< double >*
JointState::mutable_effort() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.JointState.effort)
  return &effort_;
}

// -------------------------------------------------------------------

// GoTo

// optional double max_forward_speed = 1;
inline void GoTo::clear_max_forward_speed() {
  max_forward_speed_ = 0;
}
inline double GoTo::max_forward_speed() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.GoTo.max_forward_speed)
  return max_forward_speed_;
}
inline void GoTo::set_max_forward_speed(double value) {
  
  max_forward_speed_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.GoTo.max_forward_speed)
}

// optional .robot_remote_control.Vector3 waypoint_point = 2;
inline bool GoTo::has_waypoint_point() const {
  return !_is_default_instance_ && waypoint_point_ != NULL;
}
inline void GoTo::clear_waypoint_point() {
  if (GetArenaNoVirtual() == NULL && waypoint_point_ != NULL) delete waypoint_point_;
  waypoint_point_ = NULL;
}
inline const ::robot_remote_control::Vector3& GoTo::waypoint_point() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.GoTo.waypoint_point)
  return waypoint_point_ != NULL ? *waypoint_point_ : *default_instance_->waypoint_point_;
}
inline ::robot_remote_control::Vector3* GoTo::mutable_waypoint_point() {
  
  if (waypoint_point_ == NULL) {
    waypoint_point_ = new ::robot_remote_control::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.GoTo.waypoint_point)
  return waypoint_point_;
}
inline ::robot_remote_control::Vector3* GoTo::release_waypoint_point() {
  // @@protoc_insertion_point(field_release:robot_remote_control.GoTo.waypoint_point)
  
  ::robot_remote_control::Vector3* temp = waypoint_point_;
  waypoint_point_ = NULL;
  return temp;
}
inline void GoTo::set_allocated_waypoint_point(::robot_remote_control::Vector3* waypoint_point) {
  delete waypoint_point_;
  waypoint_point_ = waypoint_point;
  if (waypoint_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.GoTo.waypoint_point)
}

// optional double waypoint_max_forward_speed = 3;
inline void GoTo::clear_waypoint_max_forward_speed() {
  waypoint_max_forward_speed_ = 0;
}
inline double GoTo::waypoint_max_forward_speed() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.GoTo.waypoint_max_forward_speed)
  return waypoint_max_forward_speed_;
}
inline void GoTo::set_waypoint_max_forward_speed(double value) {
  
  waypoint_max_forward_speed_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.GoTo.waypoint_max_forward_speed)
}

// -------------------------------------------------------------------

// SimpleActionDef

// optional .robot_remote_control.SimpleActionType type = 1;
inline void SimpleActionDef::clear_type() {
  type_ = 0;
}
inline ::robot_remote_control::SimpleActionType SimpleActionDef::type() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleActionDef.type)
  return static_cast< ::robot_remote_control::SimpleActionType >(type_);
}
inline void SimpleActionDef::set_type(::robot_remote_control::SimpleActionType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.SimpleActionDef.type)
}

// optional uint64 max_state = 2;
inline void SimpleActionDef::clear_max_state() {
  max_state_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SimpleActionDef::max_state() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleActionDef.max_state)
  return max_state_;
}
inline void SimpleActionDef::set_max_state(::google::protobuf::uint64 value) {
  
  max_state_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.SimpleActionDef.max_state)
}

// -------------------------------------------------------------------

// SimpleAction

// optional string name = 1;
inline void SimpleAction::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SimpleAction::name() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleAction.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleAction::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.SimpleAction.name)
}
inline void SimpleAction::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.SimpleAction.name)
}
inline void SimpleAction::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.SimpleAction.name)
}
inline ::std::string* SimpleAction::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.SimpleAction.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimpleAction::release_name() {
  // @@protoc_insertion_point(field_release:robot_remote_control.SimpleAction.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleAction::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.SimpleAction.name)
}

// optional .robot_remote_control.SimpleActionDef type = 2;
inline bool SimpleAction::has_type() const {
  return !_is_default_instance_ && type_ != NULL;
}
inline void SimpleAction::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) delete type_;
  type_ = NULL;
}
inline const ::robot_remote_control::SimpleActionDef& SimpleAction::type() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleAction.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::robot_remote_control::SimpleActionDef* SimpleAction::mutable_type() {
  
  if (type_ == NULL) {
    type_ = new ::robot_remote_control::SimpleActionDef;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.SimpleAction.type)
  return type_;
}
inline ::robot_remote_control::SimpleActionDef* SimpleAction::release_type() {
  // @@protoc_insertion_point(field_release:robot_remote_control.SimpleAction.type)
  
  ::robot_remote_control::SimpleActionDef* temp = type_;
  type_ = NULL;
  return temp;
}
inline void SimpleAction::set_allocated_type(::robot_remote_control::SimpleActionDef* type) {
  delete type_;
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.SimpleAction.type)
}

// optional uint64 state = 3;
inline void SimpleAction::clear_state() {
  state_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SimpleAction::state() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleAction.state)
  return state_;
}
inline void SimpleAction::set_state(::google::protobuf::uint64 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.SimpleAction.state)
}

// -------------------------------------------------------------------

// SimpleActions

// repeated .robot_remote_control.SimpleAction actions = 1;
inline int SimpleActions::actions_size() const {
  return actions_.size();
}
inline void SimpleActions::clear_actions() {
  actions_.Clear();
}
inline const ::robot_remote_control::SimpleAction& SimpleActions::actions(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleActions.actions)
  return actions_.Get(index);
}
inline ::robot_remote_control::SimpleAction* SimpleActions::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:robot_remote_control.SimpleActions.actions)
  return actions_.Mutable(index);
}
inline ::robot_remote_control::SimpleAction* SimpleActions::add_actions() {
  // @@protoc_insertion_point(field_add:robot_remote_control.SimpleActions.actions)
  return actions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleAction >*
SimpleActions::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.SimpleActions.actions)
  return &actions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleAction >&
SimpleActions::actions() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.SimpleActions.actions)
  return actions_;
}

// -------------------------------------------------------------------

// ComplexAction

// optional string name = 1;
inline void ComplexAction::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ComplexAction::name() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.ComplexAction.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComplexAction::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.ComplexAction.name)
}
inline void ComplexAction::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.ComplexAction.name)
}
inline void ComplexAction::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.ComplexAction.name)
}
inline ::std::string* ComplexAction::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.ComplexAction.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComplexAction::release_name() {
  // @@protoc_insertion_point(field_release:robot_remote_control.ComplexAction.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComplexAction::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.ComplexAction.name)
}

// optional .robot_remote_control.ComplexActionType type = 2;
inline void ComplexAction::clear_type() {
  type_ = 0;
}
inline ::robot_remote_control::ComplexActionType ComplexAction::type() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.ComplexAction.type)
  return static_cast< ::robot_remote_control::ComplexActionType >(type_);
}
inline void ComplexAction::set_type(::robot_remote_control::ComplexActionType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.ComplexAction.type)
}

// repeated .robot_remote_control.Pose poses = 3;
inline int ComplexAction::poses_size() const {
  return poses_.size();
}
inline void ComplexAction::clear_poses() {
  poses_.Clear();
}
inline const ::robot_remote_control::Pose& ComplexAction::poses(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.ComplexAction.poses)
  return poses_.Get(index);
}
inline ::robot_remote_control::Pose* ComplexAction::mutable_poses(int index) {
  // @@protoc_insertion_point(field_mutable:robot_remote_control.ComplexAction.poses)
  return poses_.Mutable(index);
}
inline ::robot_remote_control::Pose* ComplexAction::add_poses() {
  // @@protoc_insertion_point(field_add:robot_remote_control.ComplexAction.poses)
  return poses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose >*
ComplexAction::mutable_poses() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.ComplexAction.poses)
  return &poses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::Pose >&
ComplexAction::poses() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.ComplexAction.poses)
  return poses_;
}

// -------------------------------------------------------------------

// ComplexActions

// repeated .robot_remote_control.ComplexAction actions = 1;
inline int ComplexActions::actions_size() const {
  return actions_.size();
}
inline void ComplexActions::clear_actions() {
  actions_.Clear();
}
inline const ::robot_remote_control::ComplexAction& ComplexActions::actions(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.ComplexActions.actions)
  return actions_.Get(index);
}
inline ::robot_remote_control::ComplexAction* ComplexActions::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:robot_remote_control.ComplexActions.actions)
  return actions_.Mutable(index);
}
inline ::robot_remote_control::ComplexAction* ComplexActions::add_actions() {
  // @@protoc_insertion_point(field_add:robot_remote_control.ComplexActions.actions)
  return actions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::robot_remote_control::ComplexAction >*
ComplexActions::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.ComplexActions.actions)
  return &actions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::ComplexAction >&
ComplexActions::actions() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.ComplexActions.actions)
  return actions_;
}

// -------------------------------------------------------------------

// RobotName

// optional string value = 1;
inline void RobotName::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RobotName::value() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.RobotName.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotName::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.RobotName.value)
}
inline void RobotName::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.RobotName.value)
}
inline void RobotName::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.RobotName.value)
}
inline ::std::string* RobotName::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.RobotName.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RobotName::release_value() {
  // @@protoc_insertion_point(field_release:robot_remote_control.RobotName.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotName::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.RobotName.value)
}

// -------------------------------------------------------------------

// RobotState

// optional string state = 1;
inline void RobotState::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RobotState::state() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.RobotState.state)
  return state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotState::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.RobotState.state)
}
inline void RobotState::set_state(const char* value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.RobotState.state)
}
inline void RobotState::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.RobotState.state)
}
inline ::std::string* RobotState::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.RobotState.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RobotState::release_state() {
  // @@protoc_insertion_point(field_release:robot_remote_control.RobotState.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotState::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.RobotState.state)
}

// -------------------------------------------------------------------

// LogMessage

// optional uint32 level = 1;
inline void LogMessage::clear_level() {
  level_ = 0u;
}
inline ::google::protobuf::uint32 LogMessage::level() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.LogMessage.level)
  return level_;
}
inline void LogMessage::set_level(::google::protobuf::uint32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.LogMessage.level)
}

// optional string message = 2;
inline void LogMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogMessage::message() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.LogMessage.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.LogMessage.message)
}
inline void LogMessage::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.LogMessage.message)
}
inline void LogMessage::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.LogMessage.message)
}
inline ::std::string* LogMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.LogMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogMessage::release_message() {
  // @@protoc_insertion_point(field_release:robot_remote_control.LogMessage.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.LogMessage.message)
}

// -------------------------------------------------------------------

// VideoStream

// optional string url = 1;
inline void VideoStream::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoStream::url() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.VideoStream.url)
  return url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoStream::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.VideoStream.url)
}
inline void VideoStream::set_url(const char* value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.VideoStream.url)
}
inline void VideoStream::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.VideoStream.url)
}
inline ::std::string* VideoStream::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.VideoStream.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoStream::release_url() {
  // @@protoc_insertion_point(field_release:robot_remote_control.VideoStream.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoStream::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.VideoStream.url)
}

// optional .robot_remote_control.Pose camerapose = 2;
inline bool VideoStream::has_camerapose() const {
  return !_is_default_instance_ && camerapose_ != NULL;
}
inline void VideoStream::clear_camerapose() {
  if (GetArenaNoVirtual() == NULL && camerapose_ != NULL) delete camerapose_;
  camerapose_ = NULL;
}
inline const ::robot_remote_control::Pose& VideoStream::camerapose() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.VideoStream.camerapose)
  return camerapose_ != NULL ? *camerapose_ : *default_instance_->camerapose_;
}
inline ::robot_remote_control::Pose* VideoStream::mutable_camerapose() {
  
  if (camerapose_ == NULL) {
    camerapose_ = new ::robot_remote_control::Pose;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.VideoStream.camerapose)
  return camerapose_;
}
inline ::robot_remote_control::Pose* VideoStream::release_camerapose() {
  // @@protoc_insertion_point(field_release:robot_remote_control.VideoStream.camerapose)
  
  ::robot_remote_control::Pose* temp = camerapose_;
  camerapose_ = NULL;
  return temp;
}
inline void VideoStream::set_allocated_camerapose(::robot_remote_control::Pose* camerapose) {
  delete camerapose_;
  camerapose_ = camerapose;
  if (camerapose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.VideoStream.camerapose)
}

// -------------------------------------------------------------------

// VideoStreams

// repeated .robot_remote_control.VideoStream stream = 1;
inline int VideoStreams::stream_size() const {
  return stream_.size();
}
inline void VideoStreams::clear_stream() {
  stream_.Clear();
}
inline const ::robot_remote_control::VideoStream& VideoStreams::stream(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.VideoStreams.stream)
  return stream_.Get(index);
}
inline ::robot_remote_control::VideoStream* VideoStreams::mutable_stream(int index) {
  // @@protoc_insertion_point(field_mutable:robot_remote_control.VideoStreams.stream)
  return stream_.Mutable(index);
}
inline ::robot_remote_control::VideoStream* VideoStreams::add_stream() {
  // @@protoc_insertion_point(field_add:robot_remote_control.VideoStreams.stream)
  return stream_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::robot_remote_control::VideoStream >*
VideoStreams::mutable_stream() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.VideoStreams.stream)
  return &stream_;
}
inline const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::VideoStream >&
VideoStreams::stream() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.VideoStreams.stream)
  return stream_;
}

// -------------------------------------------------------------------

// SimpleSensor

// optional string name = 1;
inline void SimpleSensor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SimpleSensor::name() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleSensor.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleSensor::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_remote_control.SimpleSensor.name)
}
inline void SimpleSensor::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_remote_control.SimpleSensor.name)
}
inline void SimpleSensor::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_remote_control.SimpleSensor.name)
}
inline ::std::string* SimpleSensor::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:robot_remote_control.SimpleSensor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimpleSensor::release_name() {
  // @@protoc_insertion_point(field_release:robot_remote_control.SimpleSensor.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleSensor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.SimpleSensor.name)
}

// optional uint32 id = 2;
inline void SimpleSensor::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 SimpleSensor::id() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleSensor.id)
  return id_;
}
inline void SimpleSensor::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:robot_remote_control.SimpleSensor.id)
}

// optional .robot_remote_control.Vector2 size = 3;
inline bool SimpleSensor::has_size() const {
  return !_is_default_instance_ && size_ != NULL;
}
inline void SimpleSensor::clear_size() {
  if (GetArenaNoVirtual() == NULL && size_ != NULL) delete size_;
  size_ = NULL;
}
inline const ::robot_remote_control::Vector2& SimpleSensor::size() const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleSensor.size)
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::robot_remote_control::Vector2* SimpleSensor::mutable_size() {
  
  if (size_ == NULL) {
    size_ = new ::robot_remote_control::Vector2;
  }
  // @@protoc_insertion_point(field_mutable:robot_remote_control.SimpleSensor.size)
  return size_;
}
inline ::robot_remote_control::Vector2* SimpleSensor::release_size() {
  // @@protoc_insertion_point(field_release:robot_remote_control.SimpleSensor.size)
  
  ::robot_remote_control::Vector2* temp = size_;
  size_ = NULL;
  return temp;
}
inline void SimpleSensor::set_allocated_size(::robot_remote_control::Vector2* size) {
  delete size_;
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:robot_remote_control.SimpleSensor.size)
}

// repeated float value = 4;
inline int SimpleSensor::value_size() const {
  return value_.size();
}
inline void SimpleSensor::clear_value() {
  value_.Clear();
}
inline float SimpleSensor::value(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleSensor.value)
  return value_.Get(index);
}
inline void SimpleSensor::set_value(int index, float value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:robot_remote_control.SimpleSensor.value)
}
inline void SimpleSensor::add_value(float value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:robot_remote_control.SimpleSensor.value)
}
inline const ::google::protobuf::RepeatedField< float >&
SimpleSensor::value() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.SimpleSensor.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< float >*
SimpleSensor::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.SimpleSensor.value)
  return &value_;
}

// -------------------------------------------------------------------

// SimpleSensors

// repeated .robot_remote_control.SimpleSensor sensors = 1;
inline int SimpleSensors::sensors_size() const {
  return sensors_.size();
}
inline void SimpleSensors::clear_sensors() {
  sensors_.Clear();
}
inline const ::robot_remote_control::SimpleSensor& SimpleSensors::sensors(int index) const {
  // @@protoc_insertion_point(field_get:robot_remote_control.SimpleSensors.sensors)
  return sensors_.Get(index);
}
inline ::robot_remote_control::SimpleSensor* SimpleSensors::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:robot_remote_control.SimpleSensors.sensors)
  return sensors_.Mutable(index);
}
inline ::robot_remote_control::SimpleSensor* SimpleSensors::add_sensors() {
  // @@protoc_insertion_point(field_add:robot_remote_control.SimpleSensors.sensors)
  return sensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleSensor >*
SimpleSensors::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:robot_remote_control.SimpleSensors.sensors)
  return &sensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::robot_remote_control::SimpleSensor >&
SimpleSensors::sensors() const {
  // @@protoc_insertion_point(field_list:robot_remote_control.SimpleSensors.sensors)
  return sensors_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace robot_remote_control

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::robot_remote_control::SimpleActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robot_remote_control::SimpleActionType>() {
  return ::robot_remote_control::SimpleActionType_descriptor();
}
template <> struct is_proto_enum< ::robot_remote_control::ComplexActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robot_remote_control::ComplexActionType>() {
  return ::robot_remote_control::ComplexActionType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RobotRemoteControl_2eproto__INCLUDED
